{{- /*gotype:github.com/prisma/photongo/generator.Root*/ -}}

var schemaPath = "{{ .SchemaPath }}"

var binaries = map[string]string{
	{{ range $i, $binary := $.BinaryPaths.QueryEngine }}
		"{{ $i }}": "{{ $binary }}",
	{{ end }}
}

func getPort() (string, error) {
	addr, err := net.ResolveTCPAddr("tcp", "localhost:0")
	if err != nil {
		return "", err
	}

	l, err := net.ListenTCP("tcp", addr)
	if err != nil {
		return "", err
	}
	defer l.Close()

	port := l.Addr().(*net.TCPAddr).Port
	return strconv.Itoa(port), nil
}

func NewClient() Client {
	var debug = false
	c := Client{}
	c.debug = debug
	c.log = log.New(ioutil.Discard, "", 0)
	if debug {
		c.log = log.New(os.Stdout, "", log.Flags())
	}
	return c
}

type Client struct {
	// cmd holds the prisma binary process
	cmd *exec.Cmd

	// gql holds the internal PQL client
	gql *gqlclient.Client

	// debug notifies whether all query stdout should be outputted and redirected
	debug bool

	// logger logs depending on the debug value
	log *log.Logger

	{{ range $model := $.DMMF.Datamodel.Models }}
		{{ $model.Name.GoCase }} {{ $model.Name.GoCase }}Actions
	{{- end }}
}

func (c *Client) Connect() error {
	c.log.Printf("connecting...")

	port, err := getPort()
	if err != nil {
		return fmt.Errorf("get free port: %w", err)
	}

	gql := gqlclient.New("http://localhost:" + string(port))
	c.gql = gql

	{{- range $model := $.DMMF.Datamodel.Models }}
		c.{{ $model.Name.GoCase }} = {{ $model.Name.GoCase }}Actions{client: c}
	{{- end }}

	var path string
	for _, value := range binaries {
		path = value
		break
	}

	c.cmd = exec.Command(path, "-p", string(port))

	c.cmd.Stdout = os.Stdout
	c.cmd.Stderr = os.Stderr

	c.cmd.Env = append(
		os.Environ(),
		"PRISMA_DML_PATH=" + schemaPath,
		"RUST_LOG=error",
		"RUST_LOG_FORMAT=json",
	)

	if c.debug {
		c.cmd.Env = append(
			c.cmd.Env,
			"PRISMA_DML_PATH=" + schemaPath,
			"PRISMA_LOG_QUERIES=y",
			"RUST_LOG=info",
		)
	}

	err = c.cmd.Start()
	if err != nil {
		return fmt.Errorf("start command: %w", err)
	}

	ctx := context.Background()

	// send a basic readiness healthcheck and retry if unsuccessful
	var connectErr error
	for i := 0; i < 10; i++ {
		_, connectErr = c.gql.Raw(ctx, "", map[string]interface{}{})
		if connectErr != nil {
			c.log.Printf("could not connect; retrying...")
			time.Sleep(100 * time.Millisecond)
			continue
		}
		connectErr = nil
		break
	}

	if connectErr != nil {
		return fmt.Errorf("readiness query error: %w", err)
	}

	c.log.Printf("connected.")
	return nil
}

func (c *Client) Disconnect() error {
	c.log.Printf("disconnecting...")

	err := c.cmd.Process.Signal(os.Interrupt)
	if err != nil {
		return fmt.Errorf("send signal: %w", err)
	}

	err = c.cmd.Wait()
	if err != nil {
		return fmt.Errorf("wait for process: %w", err)
	}

	c.log.Printf("disconnected.")
	return nil
}
